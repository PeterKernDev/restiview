// general_screen.dart
// Collects general review information including restaurant, city, cuisine, date, diners, and cost.
// Uses default country from SessionCache and passes data via ReviewContext.
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'ratings_screen.dart';
import 'sub_preview_screen/review_context.dart';
import 'constants/restiview_constants.dart';
import 'constants/colours.dart';
import 'services/session_cache.dart';
import 'top_screen.dart';
import 'services/location_restaurant_helper.dart';
import 'constants/strings.dart'; // ✅ Import centralized strings

class GeneralScreen extends StatefulWidget {
  final ReviewContext context;

  const GeneralScreen({super.key, required this.context});

  @override
  State<GeneralScreen> createState() => _GeneralScreenState();
}

class _GeneralScreenState extends State<GeneralScreen> {
  final _formKey = GlobalKey<FormState>();

  late TextEditingController _restaurantController;
  late TextEditingController _cityController;
  late TextEditingController _dinersController;
  late TextEditingController _costController;
  int _restaurantSearchAttempts = 0;
  bool _isSearching = false;
  bool _showAddCuisineField = false;
  final TextEditingController _newCuisineController = TextEditingController();

  late String _selectedCuisine;
  DateTime _selectedDate = DateTime.now();
  List<NearbyRestaurant> _restaurantOptions = [];

Future<void> _addInlineCustomCuisine() async {
  final newCuisine = _newCuisineController.text.trim();
  if (newCuisine.isEmpty) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text(AppStr.cuisineRequired)),
    );
    return;
  }

  // Local duplicate check (case-insensitive)
  final existsLocally = SessionCache.customCuisines.any(
    (c) => c.toLowerCase() == newCuisine.toLowerCase(),
  );
  if (existsLocally) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text(AppStr.cuisineExists)),
    );
    return;
  }

  final uid = FirebaseAuth.instance.currentUser?.uid;
  if (uid == null) return;

  final ref = FirebaseDatabase.instance.ref('users/$uid/customvals');
  try {
    final snapshot = await ref.get();
    if (!mounted) return;

    // Build updated list of custom cuisine entries in shape: [[name, flag], ...]
    final List<List<dynamic>> updatedCustoms = [];

    if (snapshot.exists) {
      final data = snapshot.value as Map<dynamic, dynamic>;
      final raw = data['cuisine'];
      if (raw is List) {
        // defensive copy of existing items
        for (final item in raw) {
          if (item is List && item.isNotEmpty) {
            updatedCustoms.add(List<dynamic>.from(item));
          }
        }
      }
      // Add the new cuisine with flag 0
      updatedCustoms.add([newCuisine, 0]);
    } else {
      // No existing customvals node: create initial structure
      updatedCustoms.add([newCuisine, 0]);
    }

    // Sort updatedCustoms alphabetically by name, case-insensitive
    updatedCustoms.sort((a, b) =>
        (a[0] as String).toLowerCase().compareTo((b[0] as String).toLowerCase()));

    // Write back to DB (merge with other keys if node exists)
    if (snapshot.exists) {
      await ref.update({'cuisine': updatedCustoms});
    } else {
      await ref.set({
        'cuisine': updatedCustoms,
        'occasion': [],
        'country': [],
      });
    }

    // Update SessionCache.customCuisines: merge system + custom (preserve order: system then sorted customs)
    final merged = <String>[];
    // Add system cuisines first (if you want custom mixed, change this)
    for (final s in systemCuisines) {
      if (!merged.contains(s)) merged.add(s);
    }
    for (final pair in updatedCustoms) {
      final name = pair[0] as String;
      if (!merged.contains(name)) merged.add(name);
    }
    SessionCache.customCuisines = merged;

    // Set selected cuisine to the newly added value
    if (!mounted) return;
    setState(() {
      _selectedCuisine = newCuisine;
      _newCuisineController.clear();
      _showAddCuisineField = false;
    });

    // Confirm to user
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text(AppStr.cuisineAdded)),
    );
  } catch (e) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('${AppStr.saveError}: $e')),
    );
  }


  setState(() {
    SessionCache.customCuisines.add(newCuisine);
    _selectedCuisine = newCuisine;
    _newCuisineController.clear();
    _showAddCuisineField = false;
  });

  ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(content: Text(AppStr.cuisineAdded)),
  );
}

  void _clearForm() {
    setState(() {
      _restaurantController.clear();
      _cityController.clear();
      _dinersController.clear();
      _costController.clear();
      _selectedCuisine = '';
      _selectedDate = DateTime.now();

      // Clear the inline-add cuisine input and hide the field
      _newCuisineController.clear();
      _showAddCuisineField = false;

      final reviewMap = widget.context.reviewMap;
      reviewMap['restaurantName'] = '';
      reviewMap['city'] = '';
      reviewMap['cuisine'] = '';
      reviewMap['numberOfDiners'] = '';
      reviewMap['cost'] = '';
      reviewMap['dateOfReview'] = _selectedDate.toIso8601String();
      reviewMap['restaddress'] = '';
      reviewMap['restphone'] = '';
    });
  }
  //
  // Part 2
  //
  @override
  void initState() {
    super.initState();

    final reviewMap = widget.context.reviewMap;

    if (!widget.context.isEditing && reviewMap.isEmpty) {
      widget.context.reviewMap.addAll({
        'restaurantName': '',
        'country': SessionCache.defaultCountry,
        'city': '',
        'cuisine': systemCuisines.first,
        'numberOfDiners': '',
        'cost': '',
        'currency': SessionCache.currency,
        'dateOfReview': DateTime.now().toIso8601String(),
      });
      widget.context.isEditing = true;

      WidgetsBinding.instance.addPostFrameCallback((_) {
        _autoFillRestaurantFromLocation();
      });
    }

    _restaurantController = TextEditingController(text: reviewMap['restaurantName'] ?? '');
    _cityController = TextEditingController(text: reviewMap['city'] ?? '');
    _dinersController = TextEditingController(text: reviewMap['numberOfDiners']?.toString() ?? '');
    final costValue = reviewMap['cost'];
    _costController = TextEditingController(
      text: (costValue == null || costValue == '0') ? '' : costValue.toString(),
    );
    final cuisine = reviewMap['cuisine'];
    _selectedCuisine = SessionCache.customCuisines.contains(cuisine) ? cuisine : '';
    if (reviewMap['dateOfReview'] != null) {
      _selectedDate = DateTime.tryParse(reviewMap['dateOfReview']) ?? DateTime.now();
    }
  }

  void _showRestaurantSelector() async {
    final selected = await showDialog<NearbyRestaurant>(
      context: context,
      builder: (_) => SimpleDialog(
        title: const Text(AppStr.selectRestaurant),
        children: _restaurantOptions.map((rest) {
          return SimpleDialogOption(
            onPressed: () => Navigator.pop(context, rest),
            child: Text(rest.name),
          );
        }).toList(),
      ),
    );

    if (selected != null && mounted) {
      final isValidCuisine = SessionCache.customCuisines.contains(selected.cuisine);

      setState(() {
        widget.context.reviewMap['restaurantName'] = selected.name;
        widget.context.reviewMap['restaddress'] = selected.address;
        widget.context.reviewMap['restphone'] = selected.phone ?? '';
        widget.context.reviewMap['city'] = selected.city;
        widget.context.reviewMap['cuisine'] = isValidCuisine ? selected.cuisine : '';

        _restaurantController.text = selected.name;
        _cityController.text = selected.city;
        _selectedCuisine = isValidCuisine ? selected.cuisine : '';
      });
    }
  }

  void _autoFillRestaurantFromLocation() async {
    _restaurantSearchAttempts++;
    setState(() => _isSearching = true);

    try {
      final results = await findNearbyRestaurants();
      if (results.isNotEmpty && mounted) {
        _restaurantOptions = results;
        final selected = results.first;
        final isValidCuisine = SessionCache.customCuisines.contains(selected.cuisine);

        setState(() {
          widget.context.reviewMap['restaurantName'] = selected.name;
          widget.context.reviewMap['restaddress'] = selected.address;
          widget.context.reviewMap['restphone'] = selected.phone ?? '';
          widget.context.reviewMap['city'] = selected.city;
          widget.context.reviewMap['cuisine'] = isValidCuisine ? selected.cuisine : '';

          _restaurantController.text = selected.name;
          _cityController.text = selected.city;
          _selectedCuisine = isValidCuisine ? selected.cuisine : '';
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${AppStr.autoFillSuccess} ${selected.name}')),
        );
      } else {
        // debugPrint('❌ No restaurant found within ${SessionCache.searchRadius} meters.');
        if (mounted) {
          _clearForm(); // ✅ Reset the form
          final message = _restaurantSearchAttempts >= 2
              ? AppStr.autoFillFailed
              : AppStr.autoFillNone;
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(message)),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        final message = _restaurantSearchAttempts >= 2
            ? AppStr.autoFillFailed
            : 'Search failed: $e';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(message)),
        );
      }
    } finally {
      if (mounted) setState(() => _isSearching = false);
    }
  }

  @override
  void dispose() {
    _restaurantController.dispose();
    _cityController.dispose();
    _dinersController.dispose();
    _costController.dispose();
    _newCuisineController.dispose();
    super.dispose();
  }

  void _saveGeneralInfoToMap() {
    final reviewMap = widget.context.reviewMap;

    reviewMap['restaurantName'] = _restaurantController.text;
    reviewMap['country'] = SessionCache.defaultCountry;
    reviewMap['city'] = _cityController.text;
    reviewMap['cuisine'] = SessionCache.customCuisines.contains(_selectedCuisine)
        ? _selectedCuisine
        : '';
    final dinersText = _dinersController.text.trim();
    reviewMap['numberOfDiners'] = dinersText.isEmpty ? '' : int.tryParse(dinersText);
    final costText = _costController.text.trim();
    reviewMap['cost'] = costText.isEmpty ? '' : costText;
    reviewMap['currency'] = SessionCache.currency;
    reviewMap['dateOfReview'] = _selectedDate.toIso8601String();
  }

  void _goToRatingsScreen() {
    if (_formKey.currentState?.validate() ?? false) {
      _saveGeneralInfoToMap();
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => RatingsScreen(context: widget.context),
        ),
      );
    }
  }

  void _goBackToTop() async {
    final shouldLeave = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text(AppStr.discardTitle),
        content: const Text(AppStr.discardMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(AppStr.cancel),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text(AppStr.yes),
          ),
        ],
      ),
    );

    if (shouldLeave ?? false) {
      if (!mounted) return;
      Navigator.pushAndRemoveUntil(
        context,
        MaterialPageRoute(builder: (_) => TopScreen()),
        (route) => false,
      );
    }
  }
  //
  // Part 3 starts here -->
  //
@override
Widget build(BuildContext context) {
  final topCities = systemCitiesByCountry[SessionCache.defaultCountry] ?? [];
  final cuisineItemsOrdered = <String>[];
  {
    // Combine system + custom, dedupe, trim, then sort case-insensitively
    final combined = <String>[];
    combined.addAll(systemCuisines);
    combined.addAll(SessionCache.customCuisines);

    final deduped = <String>{};
    for (final raw in combined) {
      final v = raw.trim();
      if (v.isNotEmpty) deduped.add(v);
    }

    final sorted = deduped.toList()
      ..sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));
    cuisineItemsOrdered.addAll(sorted);
  }

  return Scaffold(
    backgroundColor: AppColors.beige,
    appBar: AppBar(
      automaticallyImplyLeading: false,
      title: const Text(
        AppStr.generalInfo,
        style: TextStyle(
          fontFamily: 'Gelica',
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
      ),
      backgroundColor: AppColors.darkGreen,
      centerTitle: true,
    ),
    body: LayoutBuilder(
      builder: (context, constraints) {
        return Stack(
          children: [
            SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(minHeight: constraints.maxHeight),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Form(
                    key: _formKey,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        TextFormField(
                          controller: _restaurantController,
                          decoration: const InputDecoration(labelText: AppStr.restaurantLabel),
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return AppStr.restaurantRequired;
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 16),
                        Autocomplete<String>(
                          optionsBuilder: (textEditingValue) {
                            if (textEditingValue.text == '' || topCities.isEmpty) {
                              return const Iterable<String>.empty();
                            }
                            return topCities.where((city) => city
                                .toLowerCase()
                                .contains(textEditingValue.text.toLowerCase()));
                          },
                          onSelected: (selection) {
                            _cityController.text = selection;
                          },
                          fieldViewBuilder: (context, controller, focusNode, onEditingComplete) {
                            return TextField(
                              controller: _cityController,
                              focusNode: focusNode,
                              decoration: InputDecoration(
                                labelText: AppStr.cityLabel,
                                hintText: topCities.isEmpty ? AppStr.cityHint : null,
                              ),
                              onEditingComplete: onEditingComplete,
                            );
                          },
                        ),
                        const SizedBox(height: 16),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Expanded(
                                  child: DropdownButtonFormField<String>(
                                    initialValue: cuisineItemsOrdered.contains(_selectedCuisine)
                                        ? _selectedCuisine
                                        : null,
                                    items: cuisineItemsOrdered
                                        .map((cuisine) => DropdownMenuItem(value: cuisine, child: Text(cuisine)))
                                        .toList(),
                                    onChanged: (value) {
                                      if (!mounted) return;
                                      setState(() => _selectedCuisine = value ?? '');
                                    },
                                    decoration: const InputDecoration(labelText: AppStr.cuisineLabel),
                                  ),
                                ),
                                TextButton(
                                  onPressed: () {
                                    setState(() => _showAddCuisineField = !_showAddCuisineField);
                                  },
                                  child: const Text(AppStr.add),
                                ),
                              ],
                            ),
                          if (_showAddCuisineField)
                            Padding(
                              padding: const EdgeInsets.only(top: 8.0),
                              child: Row(
                                children: [
                                  Expanded(
                                    child: TextField(
                                      controller: _newCuisineController,
                                      decoration: const InputDecoration(
                                        hintText: AppStr.newCuisineHint,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  IconButton(
                                    tooltip: AppStr.confirm,
                                    color: Colors.green,
                                    icon: const Icon(Icons.check),
                                    onPressed: () async {
                                      await _addInlineCustomCuisine();
                                    },
                                  ),
                                  IconButton(
                                    tooltip: AppStr.cancel,
                                    color: Colors.grey,
                                    icon: const Icon(Icons.close),
                                    onPressed: () {
                                      if (!mounted) return;
                                      setState(() {
                                        _newCuisineController.clear();
                                        _showAddCuisineField = false;
                                      });
                                    },
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),

                        //
                        // Part 4
                        //

                        const SizedBox(height: 16),
                        TextField(
                          controller: _dinersController,
                          keyboardType: TextInputType.number,
                          decoration: const InputDecoration(labelText: AppStr.dinersLabel),
                        ),
                        const SizedBox(height: 16),
                        Row(
                          children: [
                            const Text(AppStr.costLabel, style: TextStyle(fontSize: 16)),
                            const SizedBox(width: 12),
                            Text(SessionCache.currency, style: const TextStyle(fontSize: 16)),
                            const SizedBox(width: 12),
                            Expanded(
                              child: TextField(
                                controller: _costController,
                                keyboardType: TextInputType.number,
                                decoration: const InputDecoration(labelText: AppStr.amountLabel),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        Row(
                          children: [
                            Text('${AppStr.dateLabel} ${_selectedDate.toLocal().toString().split(' ')[0]}',
                                style: const TextStyle(fontFamily: 'Gelica')),
                            const SizedBox(width: 12),
                            ElevatedButton(
                              onPressed: () async {
                                DateTime? picked = await showDatePicker(
                                  context: context,
                                  initialDate: _selectedDate,
                                  firstDate: DateTime(2000),
                                  lastDate: DateTime(2100),
                                );
                                if (picked != null && mounted) {
                                  setState(() {
                                    _selectedDate = picked;
                                  });
                                }
                              },
                              child: const Text(AppStr.pickDate),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        Row(
                          children: [
                            const Text('Location search : ', style: TextStyle(fontFamily: 'Gelica')),
                            SessionCache.allowLocation
                                ? Expanded(
                                    child: Align(
                                      alignment: Alignment.centerRight,
                                      child: _restaurantOptions.length > 1
                                          ? ElevatedButton(
                                              onPressed: _showRestaurantSelector,
                                              style: ElevatedButton.styleFrom(backgroundColor: Colors.amber),
                                              child: const Text(AppStr.multi),
                                            )
                                          : ElevatedButton(
                                              onPressed: _autoFillRestaurantFromLocation,
                                              style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
                                              child: const Text(AppStr.search),
                                            ),
                                    ),
                                  )
                                : const Text(
                                    '(OFF)',
                                    style: TextStyle(
                                      fontFamily: 'Gelica',
                                      color: Colors.grey,
                                      fontStyle: FontStyle.italic,
                                    ),
                                  ),
                          ],
                        ),
                        const SizedBox(height: 36),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            if (_isSearching)
              Container(
                color: const Color(0xFF000000).withAlpha(77),
                child: const Center(child: CircularProgressIndicator()),
              ),
          ],
        );
      },
    ),
    bottomNavigationBar: SafeArea(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            ElevatedButton(
              onPressed: _goBackToTop,
              style: ElevatedButton.styleFrom(backgroundColor: AppColors.ochre),
              child: const Text(AppStr.back),
            ),
            ElevatedButton(
              onPressed: _clearForm,
              style: ElevatedButton.styleFrom(backgroundColor: Colors.grey),
              child: const Text(AppStr.clear),
            ),
            ElevatedButton(
              onPressed: _goToRatingsScreen,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.yellow,
                foregroundColor: Colors.black,
              ),
              child: const Text(AppStr.next),
            ),
          ],
        ),
      ),
    ),
  );
}
}